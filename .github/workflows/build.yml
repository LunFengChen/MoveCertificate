name: Build Module

on:
  push:
    branches: [ master ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:
    inputs:
      cert1:
        description: '证书1 (PEM格式或Base64)'
        required: false
        type: text
      cert2:
        description: '证书2 (PEM格式或Base64)'
        required: false
        type: text
      cert3:
        description: '证书3 (PEM格式或Base64)'
        required: false
        type: text

# 使用方法：
# 方式1: 在 certificates/ 目录上传证书文件，然后触发构建
# 方式2: 手动触发时在输入框粘贴证书内容，支持两种格式：
#        - PEM格式: -----BEGIN CERTIFICATE-----...-----END CERTIFICATE-----
#        - Base64: 证书的 base64 编码 (cat cert.pem | base64)

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Android NDK
      uses: nttld/setup-ndk@v1
      id: setup-ndk
      with:
        ndk-version: r25c
    
    - name: Build cert-hash tool
      env:
        ANDROID_NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
      run: |
        mkdir -p bin
        TOOLCHAIN="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64"
        echo "Building cert-hash for arm64..."
        $TOOLCHAIN/bin/aarch64-linux-android21-clang -static -O2 -o bin/cert-hash-arm64 tools/cert-hash.c
        echo "Building cert-hash for arm..."
        $TOOLCHAIN/bin/armv7a-linux-androideabi21-clang -static -O2 -o bin/cert-hash-arm tools/cert-hash.c
        ls -la bin/
    
    - name: Process certificates
      id: certs
      shell: bash
      run: |
        set -x
        mkdir -p certificates
        CERT_HASHES=""
        
        process_cert() {
          local cert_input="$1"
          local idx="$2"
          
          echo "Processing cert${idx}, length: ${#cert_input}"
          if [ -z "$cert_input" ]; then
            echo "cert${idx} is empty, skipping"
            return 1
          fi
          
          TEMP_PEM="/tmp/cert_${idx}.pem"
          
          # 检测是否是 PEM 格式 (包含 BEGIN CERTIFICATE)
          if echo "$cert_input" | grep -q "BEGIN CERTIFICATE"; then
            echo "cert${idx}: detected PEM format"
            # 使用 printf 保留换行
            printf '%s\n' "$cert_input" > "$TEMP_PEM"
          else
            echo "cert${idx}: detected Base64 format"
            # 移除所有空白字符后解码
            cert_b64=$(echo "$cert_input" | tr -d '[:space:]')
            if [ -z "$cert_b64" ]; then
              echo "cert${idx} base64 is empty"
              return 1
            fi
            if ! echo "$cert_b64" | base64 -d > "$TEMP_PEM" 2>/dev/null; then
              echo "cert${idx}: base64 decode failed"
              return 1
            fi
          fi
          
          echo "=== cert${idx} file content (first 500 bytes) ==="
          head -c 500 "$TEMP_PEM"
          echo ""
          echo "=== end of cert${idx} ==="
          
          # 验证是否是有效证书
          if ! openssl x509 -noout -in "$TEMP_PEM" 2>/dev/null; then
            echo "Warning: cert${idx} is not a valid certificate"
            rm -f "$TEMP_PEM"
            return 1
          fi
          
          # 计算 subject_hash_old
          HASH=$(openssl x509 -subject_hash_old -noout -in "$TEMP_PEM" 2>/dev/null)
          if [ -z "$HASH" ]; then
            echo "cert${idx}: failed to get hash"
            return 1
          fi
          
          mv "$TEMP_PEM" "certificates/${HASH}.0"
          echo "Added: ${HASH}.0"
          echo "HASH:$HASH"
          return 0
        }
        
        # 将证书写入临时文件（避免环境变量长度限制）
        cat > /tmp/cert1_input.txt << 'CERT1EOF'
        ${{ github.event.inputs.cert1 }}
        CERT1EOF
        
        cat > /tmp/cert2_input.txt << 'CERT2EOF'
        ${{ github.event.inputs.cert2 }}
        CERT2EOF
        
        cat > /tmp/cert3_input.txt << 'CERT3EOF'
        ${{ github.event.inputs.cert3 }}
        CERT3EOF
        
        # 处理每个证书
        for i in 1 2 3; do
          cert_file="/tmp/cert${i}_input.txt"
          # 读取并清理前后空白
          cert_val=$(cat "$cert_file" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | grep -v '^$' || true)
          
          if [ -n "$cert_val" ]; then
            OUTPUT=$(process_cert "$cert_val" "$i" 2>&1) || true
            echo "$OUTPUT"
            HASH=$(echo "$OUTPUT" | grep "^HASH:" | cut -d: -f2)
            if [ -n "$HASH" ]; then
              if [ -n "$CERT_HASHES" ]; then
                CERT_HASHES="${CERT_HASHES}-${HASH}"
              else
                CERT_HASHES="${HASH}"
              fi
            fi
          fi
        done
        
        echo "=== Certificates directory ==="
        ls -la certificates/ || echo "No certificates"
        echo "=== CERT_HASHES: $CERT_HASHES ==="
        
        echo "cert_hashes=$CERT_HASHES" >> $GITHUB_OUTPUT
    
    - name: Get version
      id: version
      run: |
        CERT_HASHES="${{ steps.certs.outputs.cert_hashes }}"
        
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          # tag 触发：使用 tag 名
          VERSION=${GITHUB_REF#refs/tags/}
        elif [[ -n "$CERT_HASHES" ]]; then
          # 手动触发且有证书：使用 hash 拼接
          VERSION="v1.0.0-${CERT_HASHES}"
        else
          # 其他情况：使用 commit hash
          VERSION="v1.0.0-$(git rev-parse --short HEAD)"
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"
    
    - name: Build module
      run: |
        chmod +x build.sh
        ls -la
        ls -la bin/ || true
        ls -la certificates/ || true
        if [ -d "certificates" ] && [ "$(ls -A certificates 2>/dev/null)" ]; then
          ./build.sh -v ${{ steps.version.outputs.version }} -c ./certificates
        else
          ./build.sh -v ${{ steps.version.outputs.version }}
        fi
        # 验证 zip 结构
        unzip -l MoveCertificate-*.zip | head -20
    
    - name: Prepare artifact
      run: |
        # 解压 zip 到临时目录，避免 artifact 多一层
        mkdir -p artifact
        unzip MoveCertificate-*.zip -d artifact/
    
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: MoveCertificate-${{ steps.version.outputs.version }}
        path: artifact/*
    
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/') || (github.event_name == 'push' && github.ref == 'refs/heads/master')
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ startsWith(github.ref, 'refs/tags/') && steps.version.outputs.version || 'latest' }}
        name: ${{ startsWith(github.ref, 'refs/tags/') && steps.version.outputs.version || 'Latest Build' }}
        files: MoveCertificate-*.zip
        generate_release_notes: true
        prerelease: ${{ !startsWith(github.ref, 'refs/tags/') }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
