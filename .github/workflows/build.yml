name: Build Module

on:
  push:
    branches: [ master ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

# 使用方法：
# 1. 仓库 Settings → Secrets and variables → Actions → New repository secret
# 2. 添加 CERT_1, CERT_2, ... CERT_5 (可选)
# 3. 值可以是：
#    - PEM 格式：直接粘贴 -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE-----
#    - Base64：cat cert.pem | base64 -w0
# 4. 手动触发 workflow 或 push 触发构建

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Android NDK
      uses: nttld/setup-ndk@v1
      id: setup-ndk
      with:
        ndk-version: r25c
    
    - name: Build cert-hash tool
      env:
        ANDROID_NDK_HOME: ${{ steps.setup-ndk.outputs.ndk-path }}
      run: |
        mkdir -p bin
        TOOLCHAIN="$ANDROID_NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64"
        echo "Building cert-hash for arm64..."
        $TOOLCHAIN/bin/aarch64-linux-android21-clang -static -O2 -o bin/cert-hash-arm64 tools/cert-hash.c
        echo "Building cert-hash for arm..."
        $TOOLCHAIN/bin/armv7a-linux-androideabi21-clang -static -O2 -o bin/cert-hash-arm tools/cert-hash.c
        ls -la bin/
    
    - name: Process certificates
      id: certs
      env:
        CERT_1: ${{ secrets.CERT_1 }}
        CERT_2: ${{ secrets.CERT_2 }}
        CERT_3: ${{ secrets.CERT_3 }}
        CERT_4: ${{ secrets.CERT_4 }}
        CERT_5: ${{ secrets.CERT_5 }}
      shell: bash
      run: |
        mkdir -p certificates
        CERT_HASHES=""
        
        # 只有手动触发才使用 Secrets 中的证书
        if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
          echo "=== Manual trigger: processing certificates from secrets ==="
          
          for i in 1 2 3 4 5; do
            eval "cert_val=\$CERT_$i"
            [ -z "$cert_val" ] && continue
            
            TEMP="/tmp/cert_${i}.pem"
            
            # 检测格式：PEM 或 Base64
            if echo "$cert_val" | grep -q "BEGIN CERTIFICATE"; then
              # PEM 格式直接保存
              echo "$cert_val" > "$TEMP"
            else
              # Base64 格式解码
              echo "$cert_val" | base64 -d > "$TEMP" 2>/dev/null || continue
            fi
            
            # 验证证书
            if ! openssl x509 -noout -in "$TEMP" 2>/dev/null; then
              echo "CERT_$i: invalid certificate"
              rm -f "$TEMP"
              continue
            fi
            
            HASH=$(openssl x509 -subject_hash_old -noout -in "$TEMP")
            mv "$TEMP" "certificates/${HASH}.0"
            echo "Added from secret: ${HASH}.0"
            
            [ -n "$CERT_HASHES" ] && CERT_HASHES="${CERT_HASHES}-${HASH}" || CERT_HASHES="${HASH}"
          done
        else
          echo "=== Tag/Push trigger: skipping secrets, building generic version ==="
        fi
        
        # 处理仓库中已有的证书文件（如果有）
        if [ -d "certificates" ]; then
          for cert in certificates/*.pem certificates/*.crt certificates/*.cer; do
            [ -f "$cert" ] || continue
            HASH=$(openssl x509 -subject_hash_old -noout -in "$cert" 2>/dev/null) || continue
            openssl x509 -in "$cert" -out "certificates/${HASH}.0"
            rm -f "$cert"
            echo "Converted: $(basename $cert) -> ${HASH}.0"
            [ -n "$CERT_HASHES" ] && CERT_HASHES="${CERT_HASHES}-${HASH}" || CERT_HASHES="${HASH}"
          done
        fi
        
        echo "=== Certificates ==="
        ls -la certificates/ 2>/dev/null || echo "No certificates"
        echo "cert_hashes=$CERT_HASHES" >> $GITHUB_OUTPUT
    
    - name: Get version
      id: version
      run: |
        CERT_HASHES="${{ steps.certs.outputs.cert_hashes }}"
        HAS_CERTS=""
        COMMIT_HASH=$(git rev-parse --short HEAD)
        
        # 检查是否有证书
        if [ -d "certificates" ] && [ "$(ls -A certificates 2>/dev/null)" ]; then
          HAS_CERTS="withCert"
        fi
        
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          # tag 触发：使用 tag 名
          VERSION=${GITHUB_REF#refs/tags/}
          if [[ -n "$HAS_CERTS" && -n "$CERT_HASHES" ]]; then
            VERSION="${VERSION}-${HAS_CERTS}-${CERT_HASHES}"
          fi
        else
          # push 或手动触发：都使用 commit hash
          VERSION="v1.0.1-${COMMIT_HASH}"
          if [[ -n "$HAS_CERTS" && -n "$CERT_HASHES" ]]; then
            VERSION="${VERSION}-${HAS_CERTS}-${CERT_HASHES}"
          fi
        fi
        
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "Version: $VERSION"
    
    - name: Build module
      run: |
        chmod +x build.sh
        ls -la
        ls -la bin/ || true
        ls -la certificates/ || true
        if [ -d "certificates" ] && [ "$(ls -A certificates 2>/dev/null)" ]; then
          ./build.sh -v ${{ steps.version.outputs.version }} -c ./certificates
        else
          ./build.sh -v ${{ steps.version.outputs.version }}
        fi
        # 验证 zip 结构
        unzip -l MoveCertificate-*.zip | head -20
    
    - name: Prepare artifact
      run: |
        # 解压 zip 到临时目录，避免 artifact 多一层
        mkdir -p artifact
        unzip MoveCertificate-*.zip -d artifact/
    
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: MoveCertificate-${{ steps.version.outputs.version }}
        path: artifact/*
    
    - name: Create Release
      if: startsWith(github.ref, 'refs/tags/')
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ steps.version.outputs.version }}
        name: ${{ steps.version.outputs.version }}
        files: MoveCertificate-*.zip
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
